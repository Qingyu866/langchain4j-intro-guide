<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>深度解析 - LangChain4j 学习指南</title>
    <!-- 模块化CSS -->
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <div class="page-container">
        


<aside class="sidebar">
  <div class="sidebar-content">
    <div class="sidebar-logo">
      <div class="sidebar-logo-icon">
        <svg class="sidebar-logo-svg" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
        </svg>
      </div>
      <div>
        <h1 class="sidebar-logo-title">LangChain4j</h1>
        <p class="sidebar-logo-subtitle">入门指南</p>
      </div>
    </div>

    <div class="space-y-6">
      <div class="sidebar-nav-group">
        <h3 class="sidebar-nav-title">快速开始</h3>
        <ul class="sidebar-nav-list">
          <li><a href="index.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="index">概览</a></li>
          <li><a href="getting-started.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="getting-started">环境准备</a></li>
          <li><a href="core-concepts.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="core-concepts">核心概念</a></li>
        </ul>
      </div>

      <div class="sidebar-nav-group">
        <h3 class="sidebar-nav-title">核心功能</h3>
        <ul class="sidebar-nav-list">
          <li><a href="embedding-models.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="embedding-models">Embedding 模型</a></li>
          <li><a href="prompt-templates.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="prompt-templates">Prompt 模板</a></li>
          <li><a href="output-parsers.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="output-parsers">输出解析</a></li>
          <li><a href="model-providers.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="model-providers">模型提供商</a></li>
          <li><a href="function-calling-deep.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="function-calling-deep">函数调用</a></li>
          <li><a href="advanced-features.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="advanced-features">高级特性</a></li>
          <li><a href="multimodal-full.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="multimodal-full">多模态</a></li>
        </ul>
      </div>

       <div class="sidebar-nav-group">
        <h3 class="sidebar-nav-title">RAG 完整指南</h3>
        <ul class="sidebar-nav-list">
          <li><a href="rag-intro.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="rag-intro">RAG 简介</a></li>
          <li><a href="rag-setup.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="rag-setup">RAG 环境搭建</a></li>
          <li><a href="rag-implementation.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="rag-implementation">RAG 实现</a></li>
          <li><a href="rag-advanced.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="rag-advanced">RAG 高级</a></li>
        </ul>
      </div>

      <div class="sidebar-nav-group">
        <h3 class="sidebar-nav-title">项目实战</h3>
        <ul class="sidebar-nav-list">
          <li><a href="project-chatbot.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="project-chatbot">聊天机器人</a></li>
          <li><a href="project-ai-assistant.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="project-ai-assistant">AI助手</a></li>
          <li><a href="project-rag-kb.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="project-rag-kb">RAG知识库</a></li>
          <li><a href="practice.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="practice">综合实战</a></li>
        </ul>
      </div>

      <div class="sidebar-nav-group">
        <h3 class="sidebar-nav-title">最佳实践</h3>
        <ul class="sidebar-nav-list">
          <li><a href="best-practices.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="best-practices">最佳实践</a></li>
          <li><a href="testing-strategies.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="testing-strategies">测试策略</a></li>
          <li><a href="performance-tuning.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="performance-tuning">性能优化</a></li>
          <li><a href="deep-dive.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="deep-dive">深度解析</a></li>
          <li><a href="error-handling.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="error-handling">错误处理</a></li>
          <li><a href="moderation-safety.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="moderation-safety">内容审核</a></li>
          <li><a href="troubleshooting.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="troubleshooting">故障排查</a></li>
        </ul>
      </div>

      <div class="sidebar-nav-group">
        <h3 class="sidebar-nav-title">面试准备</h3>
        <ul class="sidebar-nav-list">
          <li><a href="interview-prep.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="interview-prep">面试准备</a></li>
        </ul>
      </div>

      <div class="sidebar-nav-group">
        <h3 class="sidebar-nav-title">其他</h3>
        <ul class="sidebar-nav-list">
          <li><a href="search.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="search">向量搜索</a></li>
          <li><a href="chat-listeners.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="chat-listeners">监听器</a></li>
          <li><a href="faq.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="faq">常见问题</a></li>
          <li><a href="cost-optimization.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="cost-optimization">成本优化</a></li>
          <li><a href="deployment.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="deployment">部署上线</a></li>
          <li><a href="integrations.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="integrations">框架集成</a></li>
          <li><a href="examples.html" class="nav-link block px-4 py-2.5 text-sm text-gray-600 hover:text-indigo-700 hover:bg-indigo-50 rounded-md transition-all" data-page="examples">实战示例</a></li>
        </ul>
      </div>
    </div>
  </div>
</aside>





        <main class="main-content">
            <div class="content-wrapper">
                <!-- 页面标签 -->
                <div class="flex items-center gap-2 mb-4">
                    <span class="px-3 py-1 bg-indigo-100 text-indigo-700 text-xs font-medium rounded-full">深度解析</span>
                    <span class="px-3 py-1 bg-purple-100 text-purple-700 text-xs font-medium rounded-full">架构设计</span>
                    <span class="px-3 py-1 bg-pink-100 text-pink-700 text-xs font-medium rounded-full">源码分析</span>
                </div>

                <h1 class="text-4xl font-bold text-gray-900 mb-4">深度解析</h1>
                <p class="page-intro">深入 LangChain4j 的内部架构、设计模式和扩展机制</p>

                <!-- 目录 -->
                <nav class="bg-gray-50 border border-gray-200 rounded-xl p-6 mb-8">
                    <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-4">目录</h3>
                    <ol class="toc-list">
                        <li class="toc-item"><span class="toc-number">1.</span> <a href="#langchain4j内部架构" class="toc-link">LangChain4j 内部架构</a></li>
                        <li class="toc-item"><span class="toc-number">2.</span> <a href="#内存管理机制" class="toc-link">内存管理机制</a></li>
                        <li class="toc-item"><span class="toc-number">3.</span> <a href="#线程模型与并发" class="toc-link">线程模型与并发</a></li>
                        <li class="toc-item"><span class="toc-number">4.</span> <a href="#高级扩展性模式" class="toc-link">高级扩展性模式</a></li>
                        <li class="toc-item"><span class="toc-number">5.</span> <a href="#源码解析" class="toc-link">源码解析</a></li>
                    </ol>
                </nav>

                <!-- 第1节：LangChain4j 内部架构 -->
                <section id="langchain4j内部架构" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">1</span>
                        <h2 class="text-2xl font-bold text-gray-900">LangChain4j 内部架构</h2>
                    </div>

                    <p class="paragraph">LangChain4j 采用模块化、可扩展的架构设计。本节深入解析其核心组件、插件系统和扩展点机制。</p>

                    <h3 class="subsection-title">1.1 核心组件设计</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 的核心由四个抽象接口构成，它们共同构建了灵活的 AI 应用框架：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>ChatLanguageModel</strong>: 语言模型接口，定义了与 LLM 交互的核心方法</li>
                        <li><strong>Tool</strong>: 工具接口，封装可被 AI 调用的外部功能</li>
                        <li><strong>Memory</strong>: 内存接口，管理对话历史和上下文</li>
                        <li><strong>Chain</strong>: 链式接口，连接多个组件形成处理流程</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">自定义 ChatModel 实现</h4>
                    <p class="text-gray-700 mb-4">通过实现 ChatLanguageModel 接口，可以自定义任何 LLM 的适配器：</p>

                    <div class="code-wrapper">
                        <div class="code-filename-badge">CustomChatModel.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="code-keyword">package</span> <span class="text-blue-300">com.example.langchain4j.custom</span>;

<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.ChatLanguageModel</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.data.message.AiMessage</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.data.message.UserMessage</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.model.output.Response</span>;

<span class="text-gray-500">/**
 * 自定义 ChatLanguageModel 实现
 * 演示如何适配自定义的 LLM 服务
 */</span>
<span class="code-keyword">public class</span> <span class="code-class">CustomChatModel</span> <span class="code-keyword">implements</span> <span class="code-string">ChatLanguageModel</span> {

    <span class="code-keyword">private final</span> <span class="text-blue-300">String</span> baseUrl;
    <span class="code-keyword">private final</span> <span class="text-blue-300">String</span> apiKey;
    <span class="code-keyword">private final</span> <span class="text-blue-300">Double</span> temperature;

    <span class="text-gray-500">/**
     * 构造自定义模型
     * @param baseUrl LLM 服务的基础 URL
     * @param apiKey 认证密钥
     * @param temperature 温度参数（0.0-2.0）
     */</span>
    <span class="code-keyword">public</span> <span class="code-class">CustomChatModel</span>(<span class="text-blue-300">String</span> baseUrl, <span class="text-blue-300">String</span> apiKey, <span class="text-blue-300">Double</span> temperature) {
        <span class="code-keyword">this</span>.baseUrl = baseUrl;
        <span class="code-keyword">this</span>.apiKey = apiKey;
        <span class="code-keyword">this</span>.temperature = temperature;
    }

    <span class="text-gray-500">/**
     * 生成聊天响应
     * 核心接口方法，实现与 LLM 服务的通信
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="code-keyword">public</span> <span class="text-blue-300">Response&lt;AiMessage&gt;</span> <span class="code-class">generate</span>(<span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages) {
        <span class="text-gray-500">// 1. 构建 HTTP 请求体</span>
        <span class="text-blue-300">String</span> requestBody = buildRequestPayload(messages);

        <span class="text-gray-500">// 2. 发送 HTTP 请求到自定义 LLM 服务</span>
        <span class="text-blue-300">String</span> response = httpClient.sendRequest(
            baseUrl + <span class="code-string">"/v1/chat/completions"</span>,
            <span class="code-string">"POST"</span>,
            requestBody,
            Map.<span class="code-class">of</span>(<span class="code-string">"Authorization"</span>, <span class="code-string">"Bearer "</span> + apiKey)
        );

        <span class="text-gray-500">// 3. 解析响应并返回 AiMessage</span>
        <span class="text-blue-300">AiMessage</span> aiMessage = parseResponse(response);
        <span class="code-keyword">return new</span> <span class="code-class">Response</span>&lt;&gt;(aiMessage);
    }

    <span class="text-gray-500">/**
     * 构建请求负载
     * 将 ChatMessage 列表转换为 LLM 服务所需的格式
     */</span>
    <span class="code-keyword">private</span> <span class="text-blue-300">String</span> <span class="code-class">buildRequestPayload</span>(<span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages) {
        <span class="text-blue-300">StringBuilder</span> sb = <span class="code-keyword">new</span> <span class="code-class">StringBuilder</span>();
        sb.<span class="code-class">append</span>(<span class="code-string">"{"</span>);
        sb.<span class="code-class">append</span>(<span class="code-string">"\"model\": \"custom-model-v1\","</span>);
        sb.<span class="code-class">append</span>(<span class="code-string">"\"messages\": ["</span>);

        <span class="code-keyword">for</span> (<span class="text-blue-300">int</span> i = <span class="text-orange-300">0</span>; i &lt; messages.<span class="code-class">size</span>(); i++) {
            <span class="text-blue-300">ChatMessage</span> msg = messages.<span class="code-class">get</span>(i);
            <span class="code-keyword">if</span> (i &gt; <span class="text-orange-300">0</span>) sb.<span class="code-class">append</span>(<span class="code-string">","</span>);
            sb.<span class="code-class">append</span>(<span class="code-string">"{\"role\": \""</span>).<span class="code-class">append</span>(msg.<span class="code-class">type</span>()).<span class="code-class">append</span>(<span class="code-string">"\","</span>);
            sb.<span class="code-class">append</span>(<span class="code-string">"\"content\": \""</span>).<span class="code-class">append</span>(msg.<span class="code-class">text</span>()).<span class="code-class">append</span>(<span class="code-string">"\"}"</span>);
        }

        sb.<span class="code-class">append</span>(<span class="code-string">"],"</span>);
        sb.<span class="code-class">append</span>(<span class="code-string">"\"temperature\": "</span>).<span class="code-class">append</span>(temperature);
        sb.<span class="code-class">append</span>(<span class="code-string">"}"</span>);

        <span class="code-keyword">return</span> sb.<span class="code-class">toString</span>();
    }

    <span class="text-gray-500">/**
     * 解析 LLM 服务响应
     * 将 JSON 响应转换为 AiMessage 对象
     */</span>
    <span class="code-keyword">private</span> <span class="text-blue-300">AiMessage</span> <span class="code-class">parseResponse</span>(<span class="text-blue-300">String</span> jsonResponse) {
        <span class="text-gray-500">// 使用 JSON 库解析响应</span>
        <span class="text-blue-300">JSONObject</span> json = <span class="code-keyword">new</span> <span class="code-class">JSONObject</span>(jsonResponse);
        <span class="text-blue-300">String</span> content = json.<span class="code-class">getJSONArray</span>(<span class="code-string">"choices"</span>)
                              .<span class="code-class">getJSONObject</span>(<span class="text-orange-300">0</span>)
                              .<span class="code-class">getJSONObject</span>(<span class="code-string">"message"</span>)
                              .<span class="code-class">getString</span>(<span class="code-string">"content"</span>);
        <span class="code-keyword">return</span> <span class="code-keyword">new</span> <span class="code-class">AiMessage</span>(content);
    }
}</code></pre>
                    </div>

                    <h3 class="subsection-title">1.2 插件系统机制</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 使用 Java SPI（Service Provider Interface）实现插件系统，支持运行时动态加载扩展：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>ServiceLoader</strong>: Java 标准的服务加载机制</li>
                        <li><strong>Auto-Registration</strong>: 通过 META-INF/services 自动注册插件</li>
                        <li><strong>Priority</strong>: 插件优先级控制加载顺序</li>
                    </ul>

                    <h3 class="subsection-title">1.3 扩展点设计</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 在关键流程中定义了多个扩展点，允许开发者插入自定义逻辑：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>RequestInterceptor</strong>: 请求拦截器，在发送到 LLM 前修改请求</li>
                        <li><strong>ResponseHandler</strong>: 响应处理器，在接收 LLM 响应后进行处理</li>
                        <li><strong>TokenCounter</strong>: Token 计数器，自定义 token 计算逻辑</li>
                        <li><strong>MemoryProvider</strong>: 内存提供者，自定义对话存储策略</li>
                    </ul>
                </section>

                <!-- 第2节：内存管理机制 -->
                <section id="内存管理机制" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">2</span>
                        <h2 class="text-2xl font-bold text-gray-900">内存管理机制</h2>
                    </div>

                    <p class="paragraph">LangChain4j 提供灵活的内存管理系统，支持多种对话历史存储和检索策略。</p>

                    <h3 class="subsection-title">2.1 Message Window 实现</h3>
                    <p class="text-gray-700 mb-4">MessageWindow 是最常用的内存实现，使用滑动窗口算法管理对话历史：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>最大消息数</strong>: 限制保留的消息数量</li>
                        <li><strong>过期策略</strong>: 满载时自动移除最早的消息</li>
                        <li><strong>Token 感知</strong>: 基于 token 数量而非消息数量限制</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">自定义 Memory 实现</h4>
                    <p class="text-gray-700 mb-4">通过实现 ChatMemory 接口，可以自定义对话存储逻辑：</p>

                    <div class="code-wrapper">
                        <div class="code-filename-badge">RedisChatMemory.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="code-keyword">package</span> <span class="text-blue-300">com.example.langchain4j.memory</span>;

<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.memory.ChatMemory</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.data.message.ChatMessage</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">redis.clients.jedis.Jedis</span>;

<span class="text-gray-500">/**
 * 基于 Redis 的 ChatMemory 实现
 * 支持持久化存储和分布式部署
 */</span>
<span class="code-keyword">public class</span> <span class="code-class">RedisChatMemory</span> <span class="code-keyword">implements</span> <span class="code-string">ChatMemory</span> {

    <span class="code-keyword">private final</span> <span class="text-blue-300">String</span> sessionId;
    <span class="code-keyword">private final</span> <span class="text-blue-300">Jedis</span> jedis;
    <span class="code-keyword">private final int</span> maxMessages;

    <span class="text-gray-500">/**
     * 构造 Redis 内存
     * @param sessionId 会话唯一标识
     * @param jedis Redis 客户端
     * @param maxMessages 最大消息数
     */</span>
    <span class="code-keyword">public</span> <span class="code-class">RedisChatMemory</span>(<span class="text-blue-300">String</span> sessionId, <span class="text-blue-300">Jedis</span> jedis, <span class="text-blue-300">int</span> maxMessages) {
        <span class="code-keyword">this</span>.sessionId = sessionId;
        <span class="code-keyword">this</span>.jedis = jedis;
        <span class="code-keyword">this</span>.maxMessages = maxMessages;
    }

    <span class="text-gray-500">/**
     * 添加消息到对话历史
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="code-keyword">public void</span> <span class="code-class">add</span>(<span class="text-blue-300">ChatMessage</span> message) {
        <span class="text-blue-300">String</span> key = <span class="code-string">"chat:memory:"</span> + sessionId;
        <span class="text-blue-300">String</span> jsonMessage = serializeMessage(message);

        <span class="text-gray-500">// 使用 Redis List 存储消息（左进右出）</span>
        jedis.<span class="code-class">lpush</span>(key, jsonMessage);

        <span class="text-gray-500">// 保持最大消息数限制</span>
        jedis.<span class="code-class">ltrim</span>(key, <span class="text-orange-300">0</span>, maxMessages - <span class="text-orange-300">1</span>);

        <span class="text-gray-500">// 设置过期时间（24小时）</span>
        jedis.<span class="code-class">expire</span>(key, <span class="text-orange-300">86400</span>);
    }

    <span class="text-gray-500">/**
     * 获取对话历史中的所有消息
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="code-keyword">public</span> <span class="text-blue-300">List&lt;ChatMessage&gt;</span> <span class="code-class">messages</span>() {
        <span class="text-blue-300">String</span> key = <span class="code-string">"chat:memory:"</span> + sessionId;

        <span class="text-gray-500">// 从 Redis 获取所有消息（从右到左，保持时间顺序）</span>
        <span class="text-blue-300">List&lt;String&gt;</span> jsonMessages = jedis.<span class="code-class">lrange</span>(key, <span class="text-orange-300">0</span>, -<span class="text-orange-300">1</span>);

        <span class="text-gray-500">// 反转列表并反序列化</span>
        <span class="text-blue-300">Collections</span>.<span class="code-class">reverse</span>(jsonMessages);
        <span class="code-keyword">return</span> jsonMessages.<span class="code-class">stream</span>()
            .<span class="code-class">map</span>(<span class="code-keyword">this</span>::deserializeMessage)
            .<span class="code-class">collect</span>(<span class="text-blue-300">Collectors</span>.<span class="code-class">toList</span>());
    }

    <span class="text-gray-500">/**
     * 清空对话历史
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="code-keyword">public void</span> <span class="code-class">clear</span>() {
        <span class="text-blue-300">String</span> key = <span class="code-string">"chat:memory:"</span> + sessionId;
        jedis.<span class="code-class">del</span>(key);
    }

    <span class="text-gray-500">/**
     * 序列化消息为 JSON
     */</span>
    <span class="code-keyword">private</span> <span class="text-blue-300">String</span> <span class="code-class">serializeMessage</span>(<span class="text-blue-300">ChatMessage</span> message) {
        <span class="text-blue-300">JSONObject</span> json = <span class="code-keyword">new</span> <span class="code-class">JSONObject</span>();
        json.<span class="code-class">put</span>(<span class="code-string">"type"</span>, message.<span class="code-class">type</span>().<span class="code-class">name</span>());
        json.<span class="code-class">put</span>(<span class="code-string">"text"</span>, message.<span class="code-class">text</span>());
        <span class="code-keyword">return</span> json.<span class="code-class">toString</span>();
    }

    <span class="text-gray-500">/**
     * 从 JSON 反序列化消息
     */</span>
    <span class="code-keyword">private</span> <span class="text-blue-300">ChatMessage</span> <span class="code-class">deserializeMessage</span>(<span class="text-blue-300">String</span> json) {
        <span class="text-blue-300">JSONObject</span> obj = <span class="code-keyword">new</span> <span class="code-class">JSONObject</span>(json);
        <span class="text-blue-300">String</span> type = obj.<span class="code-class">getString</span>(<span class="code-string">"type"</span>);
        <span class="text-blue-300">String</span> text = obj.<span class="code-class">getString</span>(<span class="code-string">"text"</span>);

        <span class="code-keyword">switch</span> (type) {
            <span class="code-keyword">case</span> <span class="code-string">"USER"</span>: <span class="code-keyword">return new</span> <span class="code-class">UserMessage</span>(text);
            <span class="code-keyword">case</span> <span class="code-string">"AI"</span>: <span class="code-keyword">return new</span> <span class="code-class">AiMessage</span>(text);
            <span class="code-keyword">default</span>: <span class="code-keyword">throw new</span> <span class="code-class">IllegalArgumentException</span>(<span class="code-string">"Unknown message type: "</span> + type);
        }
    }
}</code></pre>
                    </div>

                    <h3 class="subsection-title">2.2 Token 滑动窗口</h3>
                    <p class="text-gray-700 mb-4">TokenChatMemory 实现基于 token 数量的限制，比简单的消息数量限制更精确：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>Token 计数</strong>: 使用 Tokenizer 准确计算 token 数量</li>
                        <li><strong>智能截断</strong>: 保留最新消息，自动移除最早消息</li>
                        <li><strong>跨模型兼容</strong>: 支持不同 LLM 的 token 计算方式</li>
                    </ul>

                    <h3 class="subsection-title">2.3 持久化策略</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 支持多种持久化存储后端：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>数据库</strong>: PostgreSQL、MySQL 等关系型数据库</li>
                        <li><strong>NoSQL</strong>: Redis、MongoDB 等键值存储</li>
                        <li><strong>文件系统</strong>: 本地文件或云存储</li>
                        <li><strong>自定义</strong>: 实现自定义的 ChatMemory 接口</li>
                    </ul>
                </section>

                <!-- 第3节：线程模型与并发 -->
                <section id="线程模型与并发" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">3</span>
                        <h2 class="text-2xl font-bold text-gray-900">线程模型与并发</h2>
                    </div>

                    <p class="paragraph">LangChain4j 提供同步和异步两种调用模式，并内置线程安全机制。</p>

                    <h3 class="subsection-title">3.1 同步 vs 异步调用</h3>
                    <p class="text-gray-700 mb-4">根据应用场景选择合适的调用模式：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>同步调用</strong>: 简单直接，适合单线程场景</li>
                        <li><strong>异步调用</strong>: 基于 CompletableFuture，适合高并发场景</li>
                        <li><strong>流式调用</strong>: 实时返回生成内容，提升用户体验</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">异步流式调用示例</h4>
                    <p class="text-gray-700 mb-4">使用 StreamingChatLanguageModel 实现实时流式输出：</p>

                    <div class="code-wrapper">
                        <div class="code-filename-badge">AsyncStreamingExample.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="code-keyword">package</span> <span class="text-blue-300">com.example.langchain4j.async</span>;

<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.model.openai.OpenAiStreamingChatModel</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.data.message.AiMessage</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.data.message.UserMessage</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">java.util.concurrent.CompletableFuture</span>;

<span class="text-gray-500">/**
 * 异步流式调用示例
 * 演示如何使用 StreamingChatLanguageModel 实现实时输出
 */</span>
<span class="code-keyword">public class</span> <span class="code-class">AsyncStreamingExample</span> {

    <span class="code-keyword">private final</span> <span class="text-blue-300">OpenAiStreamingChatModel</span> model;

    <span class="code-keyword">public</span> <span class="code-class">AsyncStreamingExample</span>(<span class="text-blue-300">String</span> apiKey) {
        <span class="code-keyword">this</span>.model = <span class="text-blue-300">OpenAiStreamingChatModel</span>.<span class="code-class">builder</span>()
            .<span class="code-class">apiKey</span>(apiKey)
            .<span class="code-class">modelName</span>(<span class="code-string">"gpt-4"</span>)
            .<span class="code-class">temperature</span>(<span class="text-orange-300">0.7</span>)
            .<span class="code-class">build</span>();
    }

    <span class="text-gray-500">/**
     * 异步流式调用
     * 返回 CompletableFuture，支持链式调用
     */</span>
    <span class="code-keyword">public</span> <span class="text-blue-300">CompletableFuture&lt;String&gt;</span> <span class="code-class">generateAsync</span>(<span class="text-blue-300">String</span> prompt) {
        <span class="text-blue-300">CompletableFuture&lt;String&gt;</span> future = <span class="code-keyword">new</span> <span class="code-class">CompletableFuture</span>&lt;&gt;();

        <span class="text-blue-300">StringBuilder</span> responseBuilder = <span class="code-keyword">new</span> <span class="code-class">StringBuilder</span>();

        <span class="text-gray-500">// 使用流式模型生成响应</span>
        model.<span class="code-class">generate</span>(<span class="code-keyword">new</span> <span class="code-class">UserMessage</span>(prompt), <span class="text-blue-300">StreamingResponseHandler</span>.<span class="code-class">builder</span>()
            .<span class="code-class">onPartialResponse</span>(partialResponse -&gt; {
                <span class="text-gray-500">// 收到部分响应时回调</span>
                <span class="text-blue-300">String</span> token = partialResponse.<span class="code-class">content</span>();
                responseBuilder.<span class="code-class">append</span>(token);

                <span class="text-gray-500">// 实时输出到控制台（可选）</span>
                <span class="text-blue-300">System</span>.<span class="code-class">out</span>.<span class="code-class">print</span>(token);
            })
            .<span class="code-class">onComplete</span>(completeResponse -&gt; {
                <span class="text-gray-500">// 生成完成时回调</span>
                <span class="text-blue-300">String</span> fullResponse = responseBuilder.<span class="code-class">toString</span>();
                future.<span class="code-class">complete</span>(fullResponse);
            })
            .<span class="code-class">onError</span>(error -&gt; {
                <span class="text-gray-500">// 发生错误时回调</span>
                future.<span class="code-class">completeExceptionally</span>(error);
            })
            .<span class="code-class">build</span>()
        );

        <span class="code-keyword">return</span> future;
    }

    <span class="text-gray-500">/**
     * 使用示例
     */</span>
    <span class="code-keyword">public static void</span> <span class="code-class">main</span>(<span class="text-blue-300">String</span>[] args) {
        <span class="text-blue-300">AsyncStreamingExample</span> example = <span class="code-keyword">new</span> <span class="code-class">AsyncStreamingExample</span>(<span class="code-string">"your-api-key"</span>);

        <span class="text-gray-500">// 异步生成并处理结果</span>
        example.<span class="code-class">generateAsync</span>(<span class="code-string">"介绍一下 LangChain4j 的核心特性"</span>)
            .<span class="code-class">thenAccept</span>(response -&gt; {
                <span class="text-blue-300">System</span>.<span class="code-class">out</span>.<span class="code-class">println</span>(<span class="code-string">"\n完整响应: "</span> + response);
            })
            .<span class="code-class">exceptionally</span>(error -&gt; {
                <span class="text-blue-300">System</span>.<span class="code-class">err</span>.<span class="code-class">println</span>(<span class="code-string">"生成失败: "</span> + error.<span class="code-class">getMessage</span>());
                <span class="code-keyword">return null</span>;
            });

        <span class="text-gray-500">// 主线程可以继续执行其他任务</span>
        <span class="text-blue-300">System</span>.<span class="code-class">out</span>.<span class="code-class">println</span>(<span class="code-string">"正在生成响应..."</span>);
    }
}</code></pre>
                    </div>

                    <h3 class="subsection-title">3.2 线程安全设计</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 的核心组件都是线程安全的：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>Immutable 对象</strong>: ChatLanguageModel、Tool 等核心对象不可变</li>
                        <li><strong>线程局部变量</strong>: Memory 使用线程局部变量避免竞争</li>
                        <li><strong>无状态设计</strong>: 大多数组件是无状态的，天然线程安全</li>
                    </ul>

                    <h3 class="subsection-title">3.3 并发最佳实践</h3>
                    <p class="text-gray-700 mb-4">在高并发场景下，建议遵循以下最佳实践：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>连接池</strong>: 使用 HTTP 连接池复用连接</li>
                        <li><strong>限流</strong>: 使用 RateLimiter 控制 LLM API 调用频率</li>
                        <li><strong>异步</strong>: 优先使用异步 API 避免阻塞</li>
                        <li><strong>缓存</strong>: 对重复请求使用缓存减少 LLM 调用</li>
                    </ul>
                </section>

                <!-- 第4节：高级扩展性模式 -->
                <section id="高级扩展性模式" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">4</span>
                        <h2 class="text-2xl font-bold text-gray-900">高级扩展性模式</h2>
                    </div>

                    <p class="paragraph">LangChain4j 提供多种扩展机制，支持深度定制和集成。</p>

                    <h3 class="subsection-title">4.1 自定义 ChatModel</h3>
                    <p class="text-gray-700 mb-4">通过实现 ChatLanguageModel 接口，可以集成任何 LLM 服务：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>开源模型</strong>: 集成本地部署的 Llama、Mistral 等</li>
                        <li><strong>私有云</strong>: 集成企业内部的 LLM 服务</li>
                        <li><strong>自定义协议</strong>: 适配非标准的 LLM API</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">AOP 拦截器实现</h4>
                    <p class="text-gray-700 mb-4">使用 AOP 拦截器在请求/响应生命周期中插入自定义逻辑：</p>

                    <div class="code-wrapper">
                        <div class="code-filename-badge">RequestInterceptor.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="code-keyword">package</span> <span class="text-blue-300">com.example.langchain4j.interceptor</span>;

<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.request.ChatRequest</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.response.ChatResponse</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.ChatLanguageModel</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">java.lang.reflect</span>.<span class="code-class">Proxy</span>;

<span class="text-gray-500">/**
 * AOP 拦截器实现
 * 在调用 LLM 前后插入自定义逻辑（日志、监控、权限检查等）
 */</span>
<span class="code-keyword">public class</span> <span class="code-class">RequestInterceptor</span> {

    <span class="text-gray-500">/**
     * 包装 ChatLanguageModel，添加拦截逻辑
     */</span>
    <span class="code-keyword">public static</span> <span class="text-blue-300">ChatLanguageModel</span> <span class="code-class">wrap</span>(<span class="text-blue-300">ChatLanguageModel</span> model) {
        <span class="code-keyword">return</span> (<span class="text-blue-300">ChatLanguageModel</span>) <span class="code-class">Proxy</span>.<span class="code-class">newProxyInstance</span>(
            <span class="text-blue-300">RequestInterceptor</span>.<span class="code-class">class</span>.<span class="code-class">getClassLoader</span>(),
            <span class="code-keyword">new</span> <span class="text-blue-300">Class</span>[]{<span class="text-blue-300">ChatLanguageModel</span>.<span class="code-class">class</span>},
            (<span class="text-blue-300">proxy</span>, <span class="text-blue-300">method</span>, <span class="text-blue-300">args</span>) -&gt; {
                <span class="text-gray-500">// 1. 前置处理：记录请求日志</span>
                <span class="text-blue-300">long</span> startTime = <span class="text-blue-300">System</span>.<span class="code-class">currentTimeMillis</span>();
                <span class="text-blue-300">System</span>.<span class="code-class">out</span>.<span class="code-class">println</span>(<span class="code-string">"[INTERCEPTOR] Before call: "</span> + method.<span class="code-class">getName</span>());

                <span class="text-gray-500">// 2. 执行实际的 LLM 调用</span>
                <span class="text-blue-300">Object</span> result = method.<span class="code-class">invoke</span>(model, args);

                <span class="text-gray-500">// 3. 后置处理：记录响应日志</span>
                <span class="text-blue-300">long</span> endTime = <span class="text-blue-300">System</span>.<span class="code-class">currentTimeMillis</span>();
                <span class="text-blue-300">System</span>.<span class="code-class">out</span>.<span class="code-class">println</span>(<span class="code-string">"[INTERCEPTOR] After call: "</span> + method.<span class="code-class">getName</span>() +
                    <span class="code-string">", Time: "</span> + (endTime - startTime) + <span class="code-string">"ms"</span>);

                <span class="text-gray-500">// 4. 可选：修改响应结果</span>
                <span class="code-keyword">if</span> (result <span class="code-keyword">instanceof</span> <span class="text-blue-300">ChatResponse</span>) {
                    <span class="text-blue-300">ChatResponse</span> response = (<span class="text-blue-300">ChatResponse</span>) result;
                    <span class="text-gray-500">// 可以在这里添加额外的元数据</span>
                    response.<span class="code-class">metadata</span>().<span class="code-class">put</span>(<span class="code-string">"interceptor_timestamp"</span>, endTime);
                }

                <span class="code-keyword">return</span> result;
            }
        );
    }

    <span class="text-gray-500">/**
     * 使用示例
     */</span>
    <span class="code-keyword">public static void</span> <span class="code-class">main</span>(<span class="text-blue-300">String</span>[] args) {
        <span class="text-blue-300">ChatLanguageModel</span> originalModel = <span class="text-blue-300">OpenAiChatModel</span>.<span class="code-class">builder</span>()
            .<span class="code-class">apiKey</span>(<span class="code-string">"your-api-key"</span>)
            .<span class="code-class">build</span>();

        <span class="text-gray-500">// 使用拦截器包装模型</span>
        <span class="text-blue-300">ChatLanguageModel</span> wrappedModel = <span class="code-class">RequestInterceptor</span>.<span class="code-class">wrap</span>(originalModel);

        <span class="text-gray-500">// 调用时会自动触发拦截逻辑</span>
        <span class="text-blue-300">String</span> response = wrappedModel.<span class="code-class">generate</span>(<span class="code-string">"Hello!"</span>);
        <span class="text-blue-300">System</span>.<span class="code-class">out</span>.<span class="code-class">println</span>(<span class="code-string">"Response: "</span> + response);
    }
}</code></pre>
                    </div>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">事件监听器实现</h4>
                    <p class="text-gray-700 mb-4">使用事件监听器模式解耦业务逻辑：</p>

                    <div class="code-wrapper">
                        <div class="code-filename-badge">EventListener.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="code-keyword">package</span> <span class="text-blue-300">com.example.langchain4j.listener</span>;

<span class="code-keyword">import</span> <span class="text-blue-300">java.util.ArrayList</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">java.util.List</span>;

<span class="text-gray-500">/**
 * 事件监听器
 * 监听 LLM 调用的各个生命周期事件
 */</span>
<span class="code-keyword">public class</span> <span class="code-class">EventListener</span> {

    <span class="code-keyword">private final</span> <span class="text-blue-300">List&lt;EventHandler&gt;</span> handlers = <span class="code-keyword">new</span> <span class="code-class">ArrayList</span>&lt;&gt;();

    <span class="text-gray-500">/**
     * 注册事件处理器
     */</span>
    <span class="code-keyword">public void</span> <span class="code-class">addHandler</span>(<span class="text-blue-300">EventHandler</span> handler) {
        handlers.<span class="code-class">add</span>(handler);
    }

    <span class="text-gray-500">/**
     * 触发事件
     */</span>
    <span class="code-keyword">public void</span> <span class="code-class">fireEvent</span>(<span class="text-blue-300">Event</span> event) {
        <span class="code-keyword">for</span> (<span class="text-blue-300">EventHandler</span> handler : handlers) {
            <span class="code-keyword">try</span> {
                handler.<span class="code-class">handle</span>(event);
            } <span class="code-keyword">catch</span> (<span class="text-blue-300">Exception</span> e) {
                <span class="text-blue-300">System</span>.<span class="code-class">err</span>.<span class="code-class">println</span>(<span class="code-string">"Event handler failed: "</span> + e.<span class="code-class">getMessage</span>());
            }
        }
    }

    <span class="text-gray-500">/**
     * 事件处理器接口
     */</span>
    <span class="code-keyword">public interface</span> <span class="code-class">EventHandler</span> {
        <span class="code-keyword">void</span> <span class="code-class">handle</span>(<span class="text-blue-300">Event</span> event);
    }

    <span class="text-gray-500">/**
     * 事件定义
     */</span>
    <span class="code-keyword">public static class</span> <span class="code-class">Event</span> {
        <span class="code-keyword">private final</span> <span class="text-blue-300">String</span> type;
        <span class="code-keyword">private final</span> <span class="text-blue-300">Object</span> data;

        <span class="code-keyword">public</span> <span class="code-class">Event</span>(<span class="text-blue-300">String</span> type, <span class="text-blue-300">Object</span> data) {
            <span class="code-keyword">this</span>.type = type;
            <span class="code-keyword">this</span>.data = data;
        }

        <span class="code-keyword">public</span> <span class="text-blue-300">String</span> <span class="code-class">type</span>() { <span class="code-keyword">return</span> type; }
        <span class="code-keyword">public</span> <span class="text-blue-300">Object</span> <span class="code-class">data</span>() { <span class="code-keyword">return</span> data; }
    }

    <span class="text-gray-500">/**
     * 使用示例：记录日志的事件处理器
     */</span>
    <span class="code-keyword">public static class</span> <span class="code-class">LoggingHandler</span> <span class="code-keyword">implements</span> <span class="code-class">EventHandler</span> {
        <span class="text-gray-500">@Override</span>
        <span class="code-keyword">public void</span> <span class="code-class">handle</span>(<span class="text-blue-300">Event</span> event) {
            <span class="text-blue-300">System</span>.<span class="code-class">out</span>.<span class="code-class">println</span>(<span class="code-string">"[LOG] Event: "</span> + event.<span class="code-class">type</span>() + <span class="code-string">", Data: "</span> + event.<span class="code-class">data</span>());
        }
    }

    <span class="text-gray-500">/**
     * 使用示例：监控的事件处理器
     */</span>
    <span class="code-keyword">public static class</span> <span class="code-class">MonitoringHandler</span> <span class="code-keyword">implements</span> <span class="code-class">EventHandler</span> {
        <span class="code-keyword">private long</span> startTime;

        <span class="text-gray-500">@Override</span>
        <span class="code-keyword">public void</span> <span class="code-class">handle</span>(<span class="text-blue-300">Event</span> event) {
            <span class="code-keyword">if</span> (<span class="code-string">"REQUEST_START"</span>.<span class="code-class">equals</span>(event.<span class="code-class">type</span>())) {
                startTime = <span class="text-blue-300">System</span>.<span class="code-class">currentTimeMillis</span>();
            } <span class="code-keyword">else if</span> (<span class="code-string">"RESPONSE_END"</span>.<span class="code-class">equals</span>(event.<span class="code-class">type</span>())) {
                <span class="text-blue-300">long</span> duration = <span class="text-blue-300">System</span>.<span class="code-class">currentTimeMillis</span>() - startTime;
                <span class="text-blue-300">System</span>.<span class="code-class">out</span>.<span class="code-class">println</span>(<span class="code-string">"[MONITOR] Duration: "</span> + duration + <span class="code-string">"ms"</span>);
            }
        }
    }
}</code></pre>
                    </div>

                    <h3 class="subsection-title">4.2 自定义 ToolExecutor</h3>
                    <p class="text-gray-700 mb-4">扩展工具执行器，支持更复杂的工具调用场景：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>异步执行</strong>: 支持异步工具调用</li>
                        <li><strong>批处理</strong>: 批量执行多个工具调用</li>
                        <li><strong>缓存</strong>: 缓存工具调用结果</li>
                        <li><strong>重试</strong>: 自动重试失败的工具调用</li>
                    </ul>
                </section>

                <!-- 第5节：源码解析 -->
                <section id="源码解析" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">5</span>
                        <h2 class="text-2xl font-bold text-gray-900">源码解析</h2>
                    </div>

                    <p class="paragraph">通过分析 LangChain4j 的源码，理解其设计思路和最佳实践。</p>

                    <h3 class="subsection-title">5.1 关键类设计思路</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 的核心类采用了简洁而强大的设计：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>ChatLanguageModel</strong>: 核心接口，定义了与 LLM 交互的抽象</li>
                        <li><strong>AiServices</strong>: 动态代理生成器，简化接口定义</li>
                        <li><strong>Chain</strong>: 责任链模式，连接多个处理节点</li>
                        <li><strong>ToolSpecification</strong>: 工具描述，支持函数调用</li>
                    </ul>

                    <h3 class="subsection-title">5.2 设计模式应用</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 广泛应用经典设计模式：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>Builder Pattern</strong>: 构建复杂对象（OpenAiChatModel.builder()）</li>
                        <li><strong>Strategy Pattern</strong>: 不同的 LLM 实现策略</li>
                        <li><strong>Chain of Responsibility</strong>: 处理链（Chain、ToolExecutor）</li>
                        <li><strong>Proxy Pattern</strong>: AiServices 的动态代理</li>
                        <li><strong>Template Method</strong>: 抽象基类定义算法骨架</li>
                    </ul>

                    <h3 class="subsection-title">5.3 性能优化技巧</h3>
                    <p class="text-gray-700 mb-4">从源码中学到的性能优化经验：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>连接池复用</strong>: HTTP 客户端连接池减少开销</li>
                        <li><strong>缓存设计</strong>: Token 计数结果缓存</li>
                        <li><strong>懒加载</strong>: 延迟初始化重量级资源</li>
                        <li><strong>异步非阻塞</strong>: StreamingChatModel 的流式处理</li>
                        <li><strong>对象池</strong>: 可重用对象的池化管理</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">自定义 ChatModel 核心实现</h4>
                    <p class="text-gray-700 mb-4">深入理解 ChatModel 的实现原理：</p>

                    <div class="code-wrapper">
                        <div class="code-filename-badge">ChatModelCore.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="code-keyword">package</span> <span class="text-blue-300">com.example.langchain4j.core</span>;

<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.ChatLanguageModel</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.model.output.Response</span>;
<span class="code-keyword">import</span> <span class="text-blue-300">dev.langchain4j.data.message.ChatMessage</span>;

<span class="text-gray-500">/**
 * ChatModel 核心实现示例
 * 展示 ChatLanguageModel 接口的关键实现要点
 */</span>
<span class="code-keyword">public abstract class</span> <span class="code-class">ChatModelCore</span> <span class="code-keyword">implements</span> <span class="code-string">ChatLanguageModel</span> {

    <span class="text-gray-500">/**
     * 核心生成方法
     * 子类必须实现具体的 LLM 调用逻辑
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="code-keyword">public abstract</span> <span class="text-blue-300">Response&lt;AiMessage&gt;</span> <span class="code-class">generate</span>(<span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages);

    <span class="text-gray-500">/**
     * 带系统提示的生成
     * 在消息列表前插入 SystemMessage
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="code-keyword">public</span> <span class="text-blue-300">Response&lt;AiMessage&gt;</span> <span class="code-class">generate</span>(
        <span class="text-blue-300">String</span> systemPrompt,
        <span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages
    ) {
        <span class="text-blue-300">List&lt;ChatMessage&gt;</span> fullMessages = <span class="code-keyword">new</span> <span class="code-class">ArrayList</span>&lt;&gt;();
        fullMessages.<span class="code-class">add</span>(<span class="code-keyword">new</span> <span class="code-class">SystemMessage</span>(systemPrompt));
        fullMessages.<span class="code-class">addAll</span>(messages);
        <span class="code-keyword">return</span> <span class="code-class">generate</span>(fullMessages);
    }

    <span class="text-gray-500">/**
     * 单字符串生成
     * 便捷方法，包装为 UserMessage
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="code-keyword">public</span> <span class="text-blue-300">Response&lt;AiMessage&gt;</span> <span class="code-class">generate</span>(<span class="text-blue-300">String</span> userMessage) {
        <span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages = <span class="text-blue-300">List</span>.<span class="code-class">of</span>(<span class="code-keyword">new</span> <span class="code-class">UserMessage</span>(userMessage));
        <span class="code-keyword">return</span> <span class="code-class">generate</span>(messages);
    }

    <span class="text-gray-500">/**
     * Token 计数
     * 用于估算 LLM 调用成本
     */</span>
    <span class="code-keyword">public</span> <span class="text-blue-300">int</span> <span class="code-class">estimateTokenCount</span>(<span class="text-blue-300">String</span> text) {
        <span class="text-gray-500">// 简单实现：假设 1 token ≈ 4 个字符</span>
        <span class="code-keyword">return</span> (text.<span class="code-class">length</span>() + <span class="text-orange-300">3</span>) / <span class="text-orange-300">4</span>;
    }

    <span class="text-gray-500">/**
     * 获取模型信息
     * 可用于调试和监控
     */</span>
    <span class="code-keyword">public</span> <span class="text-blue-300">String</span> <span class="code-class">getModelInfo</span>() {
        <span class="code-keyword">return this</span>.<span class="code-class">getClass</span>().<span class="code-class">getSimpleName</span>();
    }

    <span class="text-gray-500">/**
     * 资源清理
     * 关闭连接池、释放资源
     */</span>
    <span class="code-keyword">public void</span> <span class="code-class">close</span>() {
        <span class="text-gray-500">// 默认实现：无需操作</span>
        <span class="text-gray-500">// 子类可重写以释放特定资源</span>
    }
}</code></pre>
                    </div>
                </section>

                <!-- 总结 -->
                <div class="bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl p-8 text-white">
                    <h3 class="text-2xl font-bold mb-4">本章小结</h3>
                    <p class="mb-4">深度解析了 LangChain4j 的内部架构、设计模式和扩展机制。通过理解这些底层原理，您可以：</p>
                    <ul class="list-disc list-inside space-y-2 mb-6">
                        <li><strong>自定义扩展</strong>：实现自己的 ChatModel、Memory、Tool 等组件</li>
                        <li><strong>性能优化</strong>：根据应用场景选择合适的调用模式和存储策略</li>
                        <li><strong>问题诊断</strong>：通过源码理解快速定位和解决问题</li>
                        <li><strong>架构设计</strong>：借鉴 LangChain4j 的设计模式应用到自己的项目</li>
                    </ul>
                    <div class="border-t border-indigo-400 pt-6">
                        <p class="text-sm opacity-80 mb-2">核心特性</p>
                        <div class="flex flex-wrap gap-2 mb-4">
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">模块化架构</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">插件系统</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">扩展点</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">线程安全</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">异步支持</span>
                        </div>
                        <p class="text-sm opacity-80 mb-2">技术栈</p>
                        <div class="flex flex-wrap gap-2 mb-4">
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">Java 17+</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">LangChain4j</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">SPI</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">CompletableFuture</span>
                        </div>
                        <a href="error-handling.html" class="inline-flex items-center gap-2 text-white hover:text-indigo-200 transition-colors">
                            下一章：错误处理 →
                        </a>
                    </div>
                </div>
            </div>
        </main>
    </div>
</body>
</html>
