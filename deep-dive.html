<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>深度解析 - LangChain4j 学习指南</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        primary: {
                            50: '#eef2ff',
                            100: '#e0e7ff',
                            200: '#c7d2fe',
                            500: '#6366f1',
                            600: '#4f46e5',
                            700: '#4338ca',
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-white text-gray-800 antialiased">
    <div class="flex min-h-screen">
        <aside class="w-[280px] fixed left-0 top-0 h-full bg-white border-r border-gray-200 overflow-y-auto z-50">
            <a href="index.html" class="flex items-center gap-3 mb-8 text-gray-900 no-underline">
                <div class="w-9 h-9 bg-indigo-600 rounded-lg flex items-center justify-center text-white text-xl">⚡</div>
                <span class="font-bold text-xl">LangChain4j</span>
            </a>

            <div class="mb-8">
                <div class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">入门</div>
                <ul class="list-none">
                    <li><a href="index.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">首页</a></li>
                    <li><a href="getting-started.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">快速入门</a></li>
                    <li><a href="core-concepts.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">核心概念</a></li>
                </ul>
            </div>

            <div class="mb-8">
                <div class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">核心功能</div>
                <ul class="list-none">
                    <li><a href="embedding-models.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">嵌入模型</a></li>
                    <li><a href="prompt-templates.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">提示模板</a></li>
                    <li><a href="output-parsers.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">输出解析</a></li>
                    <li><a href="function-calling-deep.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">函数调用</a></li>
                    <li><a href="advanced-features.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">高级特性</a></li>
                    <li><a href="multimodal-full.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">多模态处理</a></li>
                </ul>
            </div>

            <div class="mb-8">
                <div class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">RAG 完整指南</div>
                <ul class="list-none">
                    <li><a href="rag-complete.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">RAG 完整指南</a></li>
                    <li><a href="project-rag-kb.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">RAG 知识库项目</a></li>
                </ul>
            </div>

            <div class="mb-8">
                <div class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">项目实战</div>
                <ul class="list-none">
                    <li><a href="project-ai-assistant.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">AI 助手项目</a></li>
                    <li><a href="project-chatbot.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">聊天机器人项目</a></li>
                </ul>
            </div>

            <div class="mb-8">
                <div class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">深入与最佳实践</div>
                <ul class="list-none">
                    <li><a href="best-practices.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">最佳实践</a></li>
                    <li><a href="examples.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">代码示例</a></li>
                    <li><a href="integrations.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">框架集成</a></li>
                    <li><a href="testing-strategies.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">测试策略</a></li>
                    <li><a href="performance-tuning.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">性能调优</a></li>
                    <li><a href="deep-dive.html" class="block bg-primary-50 text-indigo-700 no-underline py-2 px-3 text-sm rounded-md font-medium">深度解析</a></li>
                    <li><a href="error-handling.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">错误处理</a></li>
                    <li><a href="moderation-safety.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">内容审核与安全</a></li>
                    <li><a href="troubleshooting.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">故障排查</a></li>
                </ul>
            </div>

            <div class="mb-8">
                <div class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">高级主题</div>
                <ul class="list-none">
                    <li><a href="interview-prep.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">面试准备</a></li>
                    <li><a href="practice.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">实战练习</a></li>
                    <li><a href="search.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">搜索功能</a></li>
                    <li><a href="chat-listeners.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">聊天监听器</a></li>
                    <li><a href="faq.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">常见问题</a></li>
                    <li><a href="cost-optimization.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">成本优化</a></li>
                    <li><a href="deployment.html" class="block text-gray-600 no-underline py-2 px-3 text-sm rounded-md hover:bg-gray-100 transition-all">部署与运维</a></li>
                </ul>
            </div>
        </aside>

        <main class="flex-1 ml-[280px]">
            <div class="max-w-7xl mx-auto px-8 py-12">
                <!-- 页面标签 -->
                <div class="flex items-center gap-2 mb-4">
                    <span class="px-3 py-1 bg-indigo-100 text-indigo-700 text-xs font-medium rounded-full">深度解析</span>
                    <span class="px-3 py-1 bg-purple-100 text-purple-700 text-xs font-medium rounded-full">架构设计</span>
                    <span class="px-3 py-1 bg-pink-100 text-pink-700 text-xs font-medium rounded-full">源码分析</span>
                </div>

                <h1 class="text-4xl font-bold text-gray-900 mb-4">深度解析</h1>
                <p class="text-xl text-gray-600 mb-8">深入 LangChain4j 的内部架构、设计模式和扩展机制</p>

                <!-- 目录 -->
                <nav class="bg-gray-50 border border-gray-200 rounded-xl p-6 mb-8">
                    <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-4">目录</h3>
                    <ol class="space-y-2 text-sm text-gray-700">
                        <li class="flex items-start gap-2"><span class="text-indigo-600 font-medium">1.</span> <a href="#langchain4j内部架构" class="hover:text-indigo-600 transition-colors">LangChain4j 内部架构</a></li>
                        <li class="flex items-start gap-2"><span class="text-indigo-600 font-medium">2.</span> <a href="#内存管理机制" class="hover:text-indigo-600 transition-colors">内存管理机制</a></li>
                        <li class="flex items-start gap-2"><span class="text-indigo-600 font-medium">3.</span> <a href="#线程模型与并发" class="hover:text-indigo-600 transition-colors">线程模型与并发</a></li>
                        <li class="flex items-start gap-2"><span class="text-indigo-600 font-medium">4.</span> <a href="#高级扩展性模式" class="hover:text-indigo-600 transition-colors">高级扩展性模式</a></li>
                        <li class="flex items-start gap-2"><span class="text-indigo-600 font-medium">5.</span> <a href="#源码解析" class="hover:text-indigo-600 transition-colors">源码解析</a></li>
                    </ol>
                </nav>

                <!-- 第1节：LangChain4j 内部架构 -->
                <section id="langchain4j内部架构" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">1</span>
                        <h2 class="text-2xl font-bold text-gray-900">LangChain4j 内部架构</h2>
                    </div>

                    <p class="text-gray-700 mb-6">LangChain4j 采用模块化、可扩展的架构设计。本节深入解析其核心组件、插件系统和扩展点机制。</p>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">1.1 核心组件设计</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 的核心由四个抽象接口构成，它们共同构建了灵活的 AI 应用框架：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>ChatLanguageModel</strong>: 语言模型接口，定义了与 LLM 交互的核心方法</li>
                        <li><strong>Tool</strong>: 工具接口，封装可被 AI 调用的外部功能</li>
                        <li><strong>Memory</strong>: 内存接口，管理对话历史和上下文</li>
                        <li><strong>Chain</strong>: 链式接口，连接多个组件形成处理流程</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">自定义 ChatModel 实现</h4>
                    <p class="text-gray-700 mb-4">通过实现 ChatLanguageModel 接口，可以自定义任何 LLM 的适配器：</p>

                    <div class="relative mb-6">
                        <div class="absolute top-0 right-0 px-3 py-1 bg-gray-800 text-gray-400 text-xs font-medium rounded-bl-md">CustomChatModel.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="text-purple-400">package</span> <span class="text-blue-300">com.example.langchain4j.custom</span>;

<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.ChatLanguageModel</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.data.message.AiMessage</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.data.message.UserMessage</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.model.output.Response</span>;

<span class="text-gray-500">/**
 * 自定义 ChatLanguageModel 实现
 * 演示如何适配自定义的 LLM 服务
 */</span>
<span class="text-purple-400">public class</span> <span class="text-yellow-300">CustomChatModel</span> <span class="text-purple-400">implements</span> <span class="text-green-300">ChatLanguageModel</span> {

    <span class="text-purple-400">private final</span> <span class="text-blue-300">String</span> baseUrl;
    <span class="text-purple-400">private final</span> <span class="text-blue-300">String</span> apiKey;
    <span class="text-purple-400">private final</span> <span class="text-blue-300">Double</span> temperature;

    <span class="text-gray-500">/**
     * 构造自定义模型
     * @param baseUrl LLM 服务的基础 URL
     * @param apiKey 认证密钥
     * @param temperature 温度参数（0.0-2.0）
     */</span>
    <span class="text-purple-400">public</span> <span class="text-yellow-300">CustomChatModel</span>(<span class="text-blue-300">String</span> baseUrl, <span class="text-blue-300">String</span> apiKey, <span class="text-blue-300">Double</span> temperature) {
        <span class="text-purple-400">this</span>.baseUrl = baseUrl;
        <span class="text-purple-400">this</span>.apiKey = apiKey;
        <span class="text-purple-400">this</span>.temperature = temperature;
    }

    <span class="text-gray-500">/**
     * 生成聊天响应
     * 核心接口方法，实现与 LLM 服务的通信
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="text-purple-400">public</span> <span class="text-blue-300">Response&lt;AiMessage&gt;</span> <span class="text-yellow-300">generate</span>(<span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages) {
        <span class="text-gray-500">// 1. 构建 HTTP 请求体</span>
        <span class="text-blue-300">String</span> requestBody = buildRequestPayload(messages);

        <span class="text-gray-500">// 2. 发送 HTTP 请求到自定义 LLM 服务</span>
        <span class="text-blue-300">String</span> response = httpClient.sendRequest(
            baseUrl + <span class="text-green-300">"/v1/chat/completions"</span>,
            <span class="text-green-300">"POST"</span>,
            requestBody,
            Map.<span class="text-yellow-300">of</span>(<span class="text-green-300">"Authorization"</span>, <span class="text-green-300">"Bearer "</span> + apiKey)
        );

        <span class="text-gray-500">// 3. 解析响应并返回 AiMessage</span>
        <span class="text-blue-300">AiMessage</span> aiMessage = parseResponse(response);
        <span class="text-purple-400">return new</span> <span class="text-yellow-300">Response</span>&lt;&gt;(aiMessage);
    }

    <span class="text-gray-500">/**
     * 构建请求负载
     * 将 ChatMessage 列表转换为 LLM 服务所需的格式
     */</span>
    <span class="text-purple-400">private</span> <span class="text-blue-300">String</span> <span class="text-yellow-300">buildRequestPayload</span>(<span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages) {
        <span class="text-blue-300">StringBuilder</span> sb = <span class="text-purple-400">new</span> <span class="text-yellow-300">StringBuilder</span>();
        sb.<span class="text-yellow-300">append</span>(<span class="text-green-300">"{"</span>);
        sb.<span class="text-yellow-300">append</span>(<span class="text-green-300">"\"model\": \"custom-model-v1\","</span>);
        sb.<span class="text-yellow-300">append</span>(<span class="text-green-300">"\"messages\": ["</span>);

        <span class="text-purple-400">for</span> (<span class="text-blue-300">int</span> i = <span class="text-orange-300">0</span>; i &lt; messages.<span class="text-yellow-300">size</span>(); i++) {
            <span class="text-blue-300">ChatMessage</span> msg = messages.<span class="text-yellow-300">get</span>(i);
            <span class="text-purple-400">if</span> (i &gt; <span class="text-orange-300">0</span>) sb.<span class="text-yellow-300">append</span>(<span class="text-green-300">","</span>);
            sb.<span class="text-yellow-300">append</span>(<span class="text-green-300">"{\"role\": \""</span>).<span class="text-yellow-300">append</span>(msg.<span class="text-yellow-300">type</span>()).<span class="text-yellow-300">append</span>(<span class="text-green-300">"\","</span>);
            sb.<span class="text-yellow-300">append</span>(<span class="text-green-300">"\"content\": \""</span>).<span class="text-yellow-300">append</span>(msg.<span class="text-yellow-300">text</span>()).<span class="text-yellow-300">append</span>(<span class="text-green-300">"\"}"</span>);
        }

        sb.<span class="text-yellow-300">append</span>(<span class="text-green-300">"],"</span>);
        sb.<span class="text-yellow-300">append</span>(<span class="text-green-300">"\"temperature\": "</span>).<span class="text-yellow-300">append</span>(temperature);
        sb.<span class="text-yellow-300">append</span>(<span class="text-green-300">"}"</span>);

        <span class="text-purple-400">return</span> sb.<span class="text-yellow-300">toString</span>();
    }

    <span class="text-gray-500">/**
     * 解析 LLM 服务响应
     * 将 JSON 响应转换为 AiMessage 对象
     */</span>
    <span class="text-purple-400">private</span> <span class="text-blue-300">AiMessage</span> <span class="text-yellow-300">parseResponse</span>(<span class="text-blue-300">String</span> jsonResponse) {
        <span class="text-gray-500">// 使用 JSON 库解析响应</span>
        <span class="text-blue-300">JSONObject</span> json = <span class="text-purple-400">new</span> <span class="text-yellow-300">JSONObject</span>(jsonResponse);
        <span class="text-blue-300">String</span> content = json.<span class="text-yellow-300">getJSONArray</span>(<span class="text-green-300">"choices"</span>)
                              .<span class="text-yellow-300">getJSONObject</span>(<span class="text-orange-300">0</span>)
                              .<span class="text-yellow-300">getJSONObject</span>(<span class="text-green-300">"message"</span>)
                              .<span class="text-yellow-300">getString</span>(<span class="text-green-300">"content"</span>);
        <span class="text-purple-400">return</span> <span class="text-purple-400">new</span> <span class="text-yellow-300">AiMessage</span>(content);
    }
}</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">1.2 插件系统机制</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 使用 Java SPI（Service Provider Interface）实现插件系统，支持运行时动态加载扩展：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>ServiceLoader</strong>: Java 标准的服务加载机制</li>
                        <li><strong>Auto-Registration</strong>: 通过 META-INF/services 自动注册插件</li>
                        <li><strong>Priority</strong>: 插件优先级控制加载顺序</li>
                    </ul>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">1.3 扩展点设计</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 在关键流程中定义了多个扩展点，允许开发者插入自定义逻辑：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>RequestInterceptor</strong>: 请求拦截器，在发送到 LLM 前修改请求</li>
                        <li><strong>ResponseHandler</strong>: 响应处理器，在接收 LLM 响应后进行处理</li>
                        <li><strong>TokenCounter</strong>: Token 计数器，自定义 token 计算逻辑</li>
                        <li><strong>MemoryProvider</strong>: 内存提供者，自定义对话存储策略</li>
                    </ul>
                </section>

                <!-- 第2节：内存管理机制 -->
                <section id="内存管理机制" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">2</span>
                        <h2 class="text-2xl font-bold text-gray-900">内存管理机制</h2>
                    </div>

                    <p class="text-gray-700 mb-6">LangChain4j 提供灵活的内存管理系统，支持多种对话历史存储和检索策略。</p>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">2.1 Message Window 实现</h3>
                    <p class="text-gray-700 mb-4">MessageWindow 是最常用的内存实现，使用滑动窗口算法管理对话历史：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>最大消息数</strong>: 限制保留的消息数量</li>
                        <li><strong>过期策略</strong>: 满载时自动移除最早的消息</li>
                        <li><strong>Token 感知</strong>: 基于 token 数量而非消息数量限制</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">自定义 Memory 实现</h4>
                    <p class="text-gray-700 mb-4">通过实现 ChatMemory 接口，可以自定义对话存储逻辑：</p>

                    <div class="relative mb-6">
                        <div class="absolute top-0 right-0 px-3 py-1 bg-gray-800 text-gray-400 text-xs font-medium rounded-bl-md">RedisChatMemory.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="text-purple-400">package</span> <span class="text-blue-300">com.example.langchain4j.memory</span>;

<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.memory.ChatMemory</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.data.message.ChatMessage</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">redis.clients.jedis.Jedis</span>;

<span class="text-gray-500">/**
 * 基于 Redis 的 ChatMemory 实现
 * 支持持久化存储和分布式部署
 */</span>
<span class="text-purple-400">public class</span> <span class="text-yellow-300">RedisChatMemory</span> <span class="text-purple-400">implements</span> <span class="text-green-300">ChatMemory</span> {

    <span class="text-purple-400">private final</span> <span class="text-blue-300">String</span> sessionId;
    <span class="text-purple-400">private final</span> <span class="text-blue-300">Jedis</span> jedis;
    <span class="text-purple-400">private final int</span> maxMessages;

    <span class="text-gray-500">/**
     * 构造 Redis 内存
     * @param sessionId 会话唯一标识
     * @param jedis Redis 客户端
     * @param maxMessages 最大消息数
     */</span>
    <span class="text-purple-400">public</span> <span class="text-yellow-300">RedisChatMemory</span>(<span class="text-blue-300">String</span> sessionId, <span class="text-blue-300">Jedis</span> jedis, <span class="text-blue-300">int</span> maxMessages) {
        <span class="text-purple-400">this</span>.sessionId = sessionId;
        <span class="text-purple-400">this</span>.jedis = jedis;
        <span class="text-purple-400">this</span>.maxMessages = maxMessages;
    }

    <span class="text-gray-500">/**
     * 添加消息到对话历史
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="text-purple-400">public void</span> <span class="text-yellow-300">add</span>(<span class="text-blue-300">ChatMessage</span> message) {
        <span class="text-blue-300">String</span> key = <span class="text-green-300">"chat:memory:"</span> + sessionId;
        <span class="text-blue-300">String</span> jsonMessage = serializeMessage(message);

        <span class="text-gray-500">// 使用 Redis List 存储消息（左进右出）</span>
        jedis.<span class="text-yellow-300">lpush</span>(key, jsonMessage);

        <span class="text-gray-500">// 保持最大消息数限制</span>
        jedis.<span class="text-yellow-300">ltrim</span>(key, <span class="text-orange-300">0</span>, maxMessages - <span class="text-orange-300">1</span>);

        <span class="text-gray-500">// 设置过期时间（24小时）</span>
        jedis.<span class="text-yellow-300">expire</span>(key, <span class="text-orange-300">86400</span>);
    }

    <span class="text-gray-500">/**
     * 获取对话历史中的所有消息
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="text-purple-400">public</span> <span class="text-blue-300">List&lt;ChatMessage&gt;</span> <span class="text-yellow-300">messages</span>() {
        <span class="text-blue-300">String</span> key = <span class="text-green-300">"chat:memory:"</span> + sessionId;

        <span class="text-gray-500">// 从 Redis 获取所有消息（从右到左，保持时间顺序）</span>
        <span class="text-blue-300">List&lt;String&gt;</span> jsonMessages = jedis.<span class="text-yellow-300">lrange</span>(key, <span class="text-orange-300">0</span>, -<span class="text-orange-300">1</span>);

        <span class="text-gray-500">// 反转列表并反序列化</span>
        <span class="text-blue-300">Collections</span>.<span class="text-yellow-300">reverse</span>(jsonMessages);
        <span class="text-purple-400">return</span> jsonMessages.<span class="text-yellow-300">stream</span>()
            .<span class="text-yellow-300">map</span>(<span class="text-purple-400">this</span>::deserializeMessage)
            .<span class="text-yellow-300">collect</span>(<span class="text-blue-300">Collectors</span>.<span class="text-yellow-300">toList</span>());
    }

    <span class="text-gray-500">/**
     * 清空对话历史
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="text-purple-400">public void</span> <span class="text-yellow-300">clear</span>() {
        <span class="text-blue-300">String</span> key = <span class="text-green-300">"chat:memory:"</span> + sessionId;
        jedis.<span class="text-yellow-300">del</span>(key);
    }

    <span class="text-gray-500">/**
     * 序列化消息为 JSON
     */</span>
    <span class="text-purple-400">private</span> <span class="text-blue-300">String</span> <span class="text-yellow-300">serializeMessage</span>(<span class="text-blue-300">ChatMessage</span> message) {
        <span class="text-blue-300">JSONObject</span> json = <span class="text-purple-400">new</span> <span class="text-yellow-300">JSONObject</span>();
        json.<span class="text-yellow-300">put</span>(<span class="text-green-300">"type"</span>, message.<span class="text-yellow-300">type</span>().<span class="text-yellow-300">name</span>());
        json.<span class="text-yellow-300">put</span>(<span class="text-green-300">"text"</span>, message.<span class="text-yellow-300">text</span>());
        <span class="text-purple-400">return</span> json.<span class="text-yellow-300">toString</span>();
    }

    <span class="text-gray-500">/**
     * 从 JSON 反序列化消息
     */</span>
    <span class="text-purple-400">private</span> <span class="text-blue-300">ChatMessage</span> <span class="text-yellow-300">deserializeMessage</span>(<span class="text-blue-300">String</span> json) {
        <span class="text-blue-300">JSONObject</span> obj = <span class="text-purple-400">new</span> <span class="text-yellow-300">JSONObject</span>(json);
        <span class="text-blue-300">String</span> type = obj.<span class="text-yellow-300">getString</span>(<span class="text-green-300">"type"</span>);
        <span class="text-blue-300">String</span> text = obj.<span class="text-yellow-300">getString</span>(<span class="text-green-300">"text"</span>);

        <span class="text-purple-400">switch</span> (type) {
            <span class="text-purple-400">case</span> <span class="text-green-300">"USER"</span>: <span class="text-purple-400">return new</span> <span class="text-yellow-300">UserMessage</span>(text);
            <span class="text-purple-400">case</span> <span class="text-green-300">"AI"</span>: <span class="text-purple-400">return new</span> <span class="text-yellow-300">AiMessage</span>(text);
            <span class="text-purple-400">default</span>: <span class="text-purple-400">throw new</span> <span class="text-yellow-300">IllegalArgumentException</span>(<span class="text-green-300">"Unknown message type: "</span> + type);
        }
    }
}</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">2.2 Token 滑动窗口</h3>
                    <p class="text-gray-700 mb-4">TokenChatMemory 实现基于 token 数量的限制，比简单的消息数量限制更精确：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>Token 计数</strong>: 使用 Tokenizer 准确计算 token 数量</li>
                        <li><strong>智能截断</strong>: 保留最新消息，自动移除最早消息</li>
                        <li><strong>跨模型兼容</strong>: 支持不同 LLM 的 token 计算方式</li>
                    </ul>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">2.3 持久化策略</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 支持多种持久化存储后端：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>数据库</strong>: PostgreSQL、MySQL 等关系型数据库</li>
                        <li><strong>NoSQL</strong>: Redis、MongoDB 等键值存储</li>
                        <li><strong>文件系统</strong>: 本地文件或云存储</li>
                        <li><strong>自定义</strong>: 实现自定义的 ChatMemory 接口</li>
                    </ul>
                </section>

                <!-- 第3节：线程模型与并发 -->
                <section id="线程模型与并发" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">3</span>
                        <h2 class="text-2xl font-bold text-gray-900">线程模型与并发</h2>
                    </div>

                    <p class="text-gray-700 mb-6">LangChain4j 提供同步和异步两种调用模式，并内置线程安全机制。</p>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">3.1 同步 vs 异步调用</h3>
                    <p class="text-gray-700 mb-4">根据应用场景选择合适的调用模式：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>同步调用</strong>: 简单直接，适合单线程场景</li>
                        <li><strong>异步调用</strong>: 基于 CompletableFuture，适合高并发场景</li>
                        <li><strong>流式调用</strong>: 实时返回生成内容，提升用户体验</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">异步流式调用示例</h4>
                    <p class="text-gray-700 mb-4">使用 StreamingChatLanguageModel 实现实时流式输出：</p>

                    <div class="relative mb-6">
                        <div class="absolute top-0 right-0 px-3 py-1 bg-gray-800 text-gray-400 text-xs font-medium rounded-bl-md">AsyncStreamingExample.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="text-purple-400">package</span> <span class="text-blue-300">com.example.langchain4j.async</span>;

<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.model.openai.OpenAiStreamingChatModel</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.data.message.AiMessage</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.data.message.UserMessage</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">java.util.concurrent.CompletableFuture</span>;

<span class="text-gray-500">/**
 * 异步流式调用示例
 * 演示如何使用 StreamingChatLanguageModel 实现实时输出
 */</span>
<span class="text-purple-400">public class</span> <span class="text-yellow-300">AsyncStreamingExample</span> {

    <span class="text-purple-400">private final</span> <span class="text-blue-300">OpenAiStreamingChatModel</span> model;

    <span class="text-purple-400">public</span> <span class="text-yellow-300">AsyncStreamingExample</span>(<span class="text-blue-300">String</span> apiKey) {
        <span class="text-purple-400">this</span>.model = <span class="text-blue-300">OpenAiStreamingChatModel</span>.<span class="text-yellow-300">builder</span>()
            .<span class="text-yellow-300">apiKey</span>(apiKey)
            .<span class="text-yellow-300">modelName</span>(<span class="text-green-300">"gpt-4"</span>)
            .<span class="text-yellow-300">temperature</span>(<span class="text-orange-300">0.7</span>)
            .<span class="text-yellow-300">build</span>();
    }

    <span class="text-gray-500">/**
     * 异步流式调用
     * 返回 CompletableFuture，支持链式调用
     */</span>
    <span class="text-purple-400">public</span> <span class="text-blue-300">CompletableFuture&lt;String&gt;</span> <span class="text-yellow-300">generateAsync</span>(<span class="text-blue-300">String</span> prompt) {
        <span class="text-blue-300">CompletableFuture&lt;String&gt;</span> future = <span class="text-purple-400">new</span> <span class="text-yellow-300">CompletableFuture</span>&lt;&gt;();

        <span class="text-blue-300">StringBuilder</span> responseBuilder = <span class="text-purple-400">new</span> <span class="text-yellow-300">StringBuilder</span>();

        <span class="text-gray-500">// 使用流式模型生成响应</span>
        model.<span class="text-yellow-300">generate</span>(<span class="text-purple-400">new</span> <span class="text-yellow-300">UserMessage</span>(prompt), <span class="text-blue-300">StreamingResponseHandler</span>.<span class="text-yellow-300">builder</span>()
            .<span class="text-yellow-300">onPartialResponse</span>(partialResponse -&gt; {
                <span class="text-gray-500">// 收到部分响应时回调</span>
                <span class="text-blue-300">String</span> token = partialResponse.<span class="text-yellow-300">content</span>();
                responseBuilder.<span class="text-yellow-300">append</span>(token);

                <span class="text-gray-500">// 实时输出到控制台（可选）</span>
                <span class="text-blue-300">System</span>.<span class="text-yellow-300">out</span>.<span class="text-yellow-300">print</span>(token);
            })
            .<span class="text-yellow-300">onComplete</span>(completeResponse -&gt; {
                <span class="text-gray-500">// 生成完成时回调</span>
                <span class="text-blue-300">String</span> fullResponse = responseBuilder.<span class="text-yellow-300">toString</span>();
                future.<span class="text-yellow-300">complete</span>(fullResponse);
            })
            .<span class="text-yellow-300">onError</span>(error -&gt; {
                <span class="text-gray-500">// 发生错误时回调</span>
                future.<span class="text-yellow-300">completeExceptionally</span>(error);
            })
            .<span class="text-yellow-300">build</span>()
        );

        <span class="text-purple-400">return</span> future;
    }

    <span class="text-gray-500">/**
     * 使用示例
     */</span>
    <span class="text-purple-400">public static void</span> <span class="text-yellow-300">main</span>(<span class="text-blue-300">String</span>[] args) {
        <span class="text-blue-300">AsyncStreamingExample</span> example = <span class="text-purple-400">new</span> <span class="text-yellow-300">AsyncStreamingExample</span>(<span class="text-green-300">"your-api-key"</span>);

        <span class="text-gray-500">// 异步生成并处理结果</span>
        example.<span class="text-yellow-300">generateAsync</span>(<span class="text-green-300">"介绍一下 LangChain4j 的核心特性"</span>)
            .<span class="text-yellow-300">thenAccept</span>(response -&gt; {
                <span class="text-blue-300">System</span>.<span class="text-yellow-300">out</span>.<span class="text-yellow-300">println</span>(<span class="text-green-300">"\n完整响应: "</span> + response);
            })
            .<span class="text-yellow-300">exceptionally</span>(error -&gt; {
                <span class="text-blue-300">System</span>.<span class="text-yellow-300">err</span>.<span class="text-yellow-300">println</span>(<span class="text-green-300">"生成失败: "</span> + error.<span class="text-yellow-300">getMessage</span>());
                <span class="text-purple-400">return null</span>;
            });

        <span class="text-gray-500">// 主线程可以继续执行其他任务</span>
        <span class="text-blue-300">System</span>.<span class="text-yellow-300">out</span>.<span class="text-yellow-300">println</span>(<span class="text-green-300">"正在生成响应..."</span>);
    }
}</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">3.2 线程安全设计</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 的核心组件都是线程安全的：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>Immutable 对象</strong>: ChatLanguageModel、Tool 等核心对象不可变</li>
                        <li><strong>线程局部变量</strong>: Memory 使用线程局部变量避免竞争</li>
                        <li><strong>无状态设计</strong>: 大多数组件是无状态的，天然线程安全</li>
                    </ul>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">3.3 并发最佳实践</h3>
                    <p class="text-gray-700 mb-4">在高并发场景下，建议遵循以下最佳实践：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>连接池</strong>: 使用 HTTP 连接池复用连接</li>
                        <li><strong>限流</strong>: 使用 RateLimiter 控制 LLM API 调用频率</li>
                        <li><strong>异步</strong>: 优先使用异步 API 避免阻塞</li>
                        <li><strong>缓存</strong>: 对重复请求使用缓存减少 LLM 调用</li>
                    </ul>
                </section>

                <!-- 第4节：高级扩展性模式 -->
                <section id="高级扩展性模式" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">4</span>
                        <h2 class="text-2xl font-bold text-gray-900">高级扩展性模式</h2>
                    </div>

                    <p class="text-gray-700 mb-6">LangChain4j 提供多种扩展机制，支持深度定制和集成。</p>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">4.1 自定义 ChatModel</h3>
                    <p class="text-gray-700 mb-4">通过实现 ChatLanguageModel 接口，可以集成任何 LLM 服务：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>开源模型</strong>: 集成本地部署的 Llama、Mistral 等</li>
                        <li><strong>私有云</strong>: 集成企业内部的 LLM 服务</li>
                        <li><strong>自定义协议</strong>: 适配非标准的 LLM API</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">AOP 拦截器实现</h4>
                    <p class="text-gray-700 mb-4">使用 AOP 拦截器在请求/响应生命周期中插入自定义逻辑：</p>

                    <div class="relative mb-6">
                        <div class="absolute top-0 right-0 px-3 py-1 bg-gray-800 text-gray-400 text-xs font-medium rounded-bl-md">RequestInterceptor.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="text-purple-400">package</span> <span class="text-blue-300">com.example.langchain4j.interceptor</span>;

<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.request.ChatRequest</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.response.ChatResponse</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.ChatLanguageModel</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">java.lang.reflect</span>.<span class="text-yellow-300">Proxy</span>;

<span class="text-gray-500">/**
 * AOP 拦截器实现
 * 在调用 LLM 前后插入自定义逻辑（日志、监控、权限检查等）
 */</span>
<span class="text-purple-400">public class</span> <span class="text-yellow-300">RequestInterceptor</span> {

    <span class="text-gray-500">/**
     * 包装 ChatLanguageModel，添加拦截逻辑
     */</span>
    <span class="text-purple-400">public static</span> <span class="text-blue-300">ChatLanguageModel</span> <span class="text-yellow-300">wrap</span>(<span class="text-blue-300">ChatLanguageModel</span> model) {
        <span class="text-purple-400">return</span> (<span class="text-blue-300">ChatLanguageModel</span>) <span class="text-yellow-300">Proxy</span>.<span class="text-yellow-300">newProxyInstance</span>(
            <span class="text-blue-300">RequestInterceptor</span>.<span class="text-yellow-300">class</span>.<span class="text-yellow-300">getClassLoader</span>(),
            <span class="text-purple-400">new</span> <span class="text-blue-300">Class</span>[]{<span class="text-blue-300">ChatLanguageModel</span>.<span class="text-yellow-300">class</span>},
            (<span class="text-blue-300">proxy</span>, <span class="text-blue-300">method</span>, <span class="text-blue-300">args</span>) -&gt; {
                <span class="text-gray-500">// 1. 前置处理：记录请求日志</span>
                <span class="text-blue-300">long</span> startTime = <span class="text-blue-300">System</span>.<span class="text-yellow-300">currentTimeMillis</span>();
                <span class="text-blue-300">System</span>.<span class="text-yellow-300">out</span>.<span class="text-yellow-300">println</span>(<span class="text-green-300">"[INTERCEPTOR] Before call: "</span> + method.<span class="text-yellow-300">getName</span>());

                <span class="text-gray-500">// 2. 执行实际的 LLM 调用</span>
                <span class="text-blue-300">Object</span> result = method.<span class="text-yellow-300">invoke</span>(model, args);

                <span class="text-gray-500">// 3. 后置处理：记录响应日志</span>
                <span class="text-blue-300">long</span> endTime = <span class="text-blue-300">System</span>.<span class="text-yellow-300">currentTimeMillis</span>();
                <span class="text-blue-300">System</span>.<span class="text-yellow-300">out</span>.<span class="text-yellow-300">println</span>(<span class="text-green-300">"[INTERCEPTOR] After call: "</span> + method.<span class="text-yellow-300">getName</span>() +
                    <span class="text-green-300">", Time: "</span> + (endTime - startTime) + <span class="text-green-300">"ms"</span>);

                <span class="text-gray-500">// 4. 可选：修改响应结果</span>
                <span class="text-purple-400">if</span> (result <span class="text-purple-400">instanceof</span> <span class="text-blue-300">ChatResponse</span>) {
                    <span class="text-blue-300">ChatResponse</span> response = (<span class="text-blue-300">ChatResponse</span>) result;
                    <span class="text-gray-500">// 可以在这里添加额外的元数据</span>
                    response.<span class="text-yellow-300">metadata</span>().<span class="text-yellow-300">put</span>(<span class="text-green-300">"interceptor_timestamp"</span>, endTime);
                }

                <span class="text-purple-400">return</span> result;
            }
        );
    }

    <span class="text-gray-500">/**
     * 使用示例
     */</span>
    <span class="text-purple-400">public static void</span> <span class="text-yellow-300">main</span>(<span class="text-blue-300">String</span>[] args) {
        <span class="text-blue-300">ChatLanguageModel</span> originalModel = <span class="text-blue-300">OpenAiChatModel</span>.<span class="text-yellow-300">builder</span>()
            .<span class="text-yellow-300">apiKey</span>(<span class="text-green-300">"your-api-key"</span>)
            .<span class="text-yellow-300">build</span>();

        <span class="text-gray-500">// 使用拦截器包装模型</span>
        <span class="text-blue-300">ChatLanguageModel</span> wrappedModel = <span class="text-yellow-300">RequestInterceptor</span>.<span class="text-yellow-300">wrap</span>(originalModel);

        <span class="text-gray-500">// 调用时会自动触发拦截逻辑</span>
        <span class="text-blue-300">String</span> response = wrappedModel.<span class="text-yellow-300">generate</span>(<span class="text-green-300">"Hello!"</span>);
        <span class="text-blue-300">System</span>.<span class="text-yellow-300">out</span>.<span class="text-yellow-300">println</span>(<span class="text-green-300">"Response: "</span> + response);
    }
}</code></pre>
                    </div>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">事件监听器实现</h4>
                    <p class="text-gray-700 mb-4">使用事件监听器模式解耦业务逻辑：</p>

                    <div class="relative mb-6">
                        <div class="absolute top-0 right-0 px-3 py-1 bg-gray-800 text-gray-400 text-xs font-medium rounded-bl-md">EventListener.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="text-purple-400">package</span> <span class="text-blue-300">com.example.langchain4j.listener</span>;

<span class="text-purple-400">import</span> <span class="text-blue-300">java.util.ArrayList</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">java.util.List</span>;

<span class="text-gray-500">/**
 * 事件监听器
 * 监听 LLM 调用的各个生命周期事件
 */</span>
<span class="text-purple-400">public class</span> <span class="text-yellow-300">EventListener</span> {

    <span class="text-purple-400">private final</span> <span class="text-blue-300">List&lt;EventHandler&gt;</span> handlers = <span class="text-purple-400">new</span> <span class="text-yellow-300">ArrayList</span>&lt;&gt;();

    <span class="text-gray-500">/**
     * 注册事件处理器
     */</span>
    <span class="text-purple-400">public void</span> <span class="text-yellow-300">addHandler</span>(<span class="text-blue-300">EventHandler</span> handler) {
        handlers.<span class="text-yellow-300">add</span>(handler);
    }

    <span class="text-gray-500">/**
     * 触发事件
     */</span>
    <span class="text-purple-400">public void</span> <span class="text-yellow-300">fireEvent</span>(<span class="text-blue-300">Event</span> event) {
        <span class="text-purple-400">for</span> (<span class="text-blue-300">EventHandler</span> handler : handlers) {
            <span class="text-purple-400">try</span> {
                handler.<span class="text-yellow-300">handle</span>(event);
            } <span class="text-purple-400">catch</span> (<span class="text-blue-300">Exception</span> e) {
                <span class="text-blue-300">System</span>.<span class="text-yellow-300">err</span>.<span class="text-yellow-300">println</span>(<span class="text-green-300">"Event handler failed: "</span> + e.<span class="text-yellow-300">getMessage</span>());
            }
        }
    }

    <span class="text-gray-500">/**
     * 事件处理器接口
     */</span>
    <span class="text-purple-400">public interface</span> <span class="text-yellow-300">EventHandler</span> {
        <span class="text-purple-400">void</span> <span class="text-yellow-300">handle</span>(<span class="text-blue-300">Event</span> event);
    }

    <span class="text-gray-500">/**
     * 事件定义
     */</span>
    <span class="text-purple-400">public static class</span> <span class="text-yellow-300">Event</span> {
        <span class="text-purple-400">private final</span> <span class="text-blue-300">String</span> type;
        <span class="text-purple-400">private final</span> <span class="text-blue-300">Object</span> data;

        <span class="text-purple-400">public</span> <span class="text-yellow-300">Event</span>(<span class="text-blue-300">String</span> type, <span class="text-blue-300">Object</span> data) {
            <span class="text-purple-400">this</span>.type = type;
            <span class="text-purple-400">this</span>.data = data;
        }

        <span class="text-purple-400">public</span> <span class="text-blue-300">String</span> <span class="text-yellow-300">type</span>() { <span class="text-purple-400">return</span> type; }
        <span class="text-purple-400">public</span> <span class="text-blue-300">Object</span> <span class="text-yellow-300">data</span>() { <span class="text-purple-400">return</span> data; }
    }

    <span class="text-gray-500">/**
     * 使用示例：记录日志的事件处理器
     */</span>
    <span class="text-purple-400">public static class</span> <span class="text-yellow-300">LoggingHandler</span> <span class="text-purple-400">implements</span> <span class="text-yellow-300">EventHandler</span> {
        <span class="text-gray-500">@Override</span>
        <span class="text-purple-400">public void</span> <span class="text-yellow-300">handle</span>(<span class="text-blue-300">Event</span> event) {
            <span class="text-blue-300">System</span>.<span class="text-yellow-300">out</span>.<span class="text-yellow-300">println</span>(<span class="text-green-300">"[LOG] Event: "</span> + event.<span class="text-yellow-300">type</span>() + <span class="text-green-300">", Data: "</span> + event.<span class="text-yellow-300">data</span>());
        }
    }

    <span class="text-gray-500">/**
     * 使用示例：监控的事件处理器
     */</span>
    <span class="text-purple-400">public static class</span> <span class="text-yellow-300">MonitoringHandler</span> <span class="text-purple-400">implements</span> <span class="text-yellow-300">EventHandler</span> {
        <span class="text-purple-400">private long</span> startTime;

        <span class="text-gray-500">@Override</span>
        <span class="text-purple-400">public void</span> <span class="text-yellow-300">handle</span>(<span class="text-blue-300">Event</span> event) {
            <span class="text-purple-400">if</span> (<span class="text-green-300">"REQUEST_START"</span>.<span class="text-yellow-300">equals</span>(event.<span class="text-yellow-300">type</span>())) {
                startTime = <span class="text-blue-300">System</span>.<span class="text-yellow-300">currentTimeMillis</span>();
            } <span class="text-purple-400">else if</span> (<span class="text-green-300">"RESPONSE_END"</span>.<span class="text-yellow-300">equals</span>(event.<span class="text-yellow-300">type</span>())) {
                <span class="text-blue-300">long</span> duration = <span class="text-blue-300">System</span>.<span class="text-yellow-300">currentTimeMillis</span>() - startTime;
                <span class="text-blue-300">System</span>.<span class="text-yellow-300">out</span>.<span class="text-yellow-300">println</span>(<span class="text-green-300">"[MONITOR] Duration: "</span> + duration + <span class="text-green-300">"ms"</span>);
            }
        }
    }
}</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">4.2 自定义 ToolExecutor</h3>
                    <p class="text-gray-700 mb-4">扩展工具执行器，支持更复杂的工具调用场景：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>异步执行</strong>: 支持异步工具调用</li>
                        <li><strong>批处理</strong>: 批量执行多个工具调用</li>
                        <li><strong>缓存</strong>: 缓存工具调用结果</li>
                        <li><strong>重试</strong>: 自动重试失败的工具调用</li>
                    </ul>
                </section>

                <!-- 第5节：源码解析 -->
                <section id="源码解析" class="mb-16">
                    <div class="flex items-center gap-3 mb-6">
                        <span class="flex items-center justify-center w-8 h-8 bg-indigo-600 text-white rounded-full text-sm font-bold">5</span>
                        <h2 class="text-2xl font-bold text-gray-900">源码解析</h2>
                    </div>

                    <p class="text-gray-700 mb-6">通过分析 LangChain4j 的源码，理解其设计思路和最佳实践。</p>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">5.1 关键类设计思路</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 的核心类采用了简洁而强大的设计：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>ChatLanguageModel</strong>: 核心接口，定义了与 LLM 交互的抽象</li>
                        <li><strong>AiServices</strong>: 动态代理生成器，简化接口定义</li>
                        <li><strong>Chain</strong>: 责任链模式，连接多个处理节点</li>
                        <li><strong>ToolSpecification</strong>: 工具描述，支持函数调用</li>
                    </ul>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">5.2 设计模式应用</h3>
                    <p class="text-gray-700 mb-4">LangChain4j 广泛应用经典设计模式：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>Builder Pattern</strong>: 构建复杂对象（OpenAiChatModel.builder()）</li>
                        <li><strong>Strategy Pattern</strong>: 不同的 LLM 实现策略</li>
                        <li><strong>Chain of Responsibility</strong>: 处理链（Chain、ToolExecutor）</li>
                        <li><strong>Proxy Pattern</strong>: AiServices 的动态代理</li>
                        <li><strong>Template Method</strong>: 抽象基类定义算法骨架</li>
                    </ul>

                    <h3 class="text-xl font-semibold text-gray-900 mb-4">5.3 性能优化技巧</h3>
                    <p class="text-gray-700 mb-4">从源码中学到的性能优化经验：</p>

                    <ul class="list-disc list-inside text-gray-700 mb-6 space-y-2">
                        <li><strong>连接池复用</strong>: HTTP 客户端连接池减少开销</li>
                        <li><strong>缓存设计</strong>: Token 计数结果缓存</li>
                        <li><strong>懒加载</strong>: 延迟初始化重量级资源</li>
                        <li><strong>异步非阻塞</strong>: StreamingChatModel 的流式处理</li>
                        <li><strong>对象池</strong>: 可重用对象的池化管理</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-gray-900 mb-3">自定义 ChatModel 核心实现</h4>
                    <p class="text-gray-700 mb-4">深入理解 ChatModel 的实现原理：</p>

                    <div class="relative mb-6">
                        <div class="absolute top-0 right-0 px-3 py-1 bg-gray-800 text-gray-400 text-xs font-medium rounded-bl-md">ChatModelCore.java</div>
                        <pre class="bg-gray-900 text-gray-100 rounded-lg p-5 overflow-x-auto"><code class="text-sm"><span class="text-purple-400">package</span> <span class="text-blue-300">com.example.langchain4j.core</span>;

<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.model.chat.ChatLanguageModel</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.model.output.Response</span>;
<span class="text-purple-400">import</span> <span class="text-blue-300">dev.langchain4j.data.message.ChatMessage</span>;

<span class="text-gray-500">/**
 * ChatModel 核心实现示例
 * 展示 ChatLanguageModel 接口的关键实现要点
 */</span>
<span class="text-purple-400">public abstract class</span> <span class="text-yellow-300">ChatModelCore</span> <span class="text-purple-400">implements</span> <span class="text-green-300">ChatLanguageModel</span> {

    <span class="text-gray-500">/**
     * 核心生成方法
     * 子类必须实现具体的 LLM 调用逻辑
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="text-purple-400">public abstract</span> <span class="text-blue-300">Response&lt;AiMessage&gt;</span> <span class="text-yellow-300">generate</span>(<span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages);

    <span class="text-gray-500">/**
     * 带系统提示的生成
     * 在消息列表前插入 SystemMessage
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="text-purple-400">public</span> <span class="text-blue-300">Response&lt;AiMessage&gt;</span> <span class="text-yellow-300">generate</span>(
        <span class="text-blue-300">String</span> systemPrompt,
        <span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages
    ) {
        <span class="text-blue-300">List&lt;ChatMessage&gt;</span> fullMessages = <span class="text-purple-400">new</span> <span class="text-yellow-300">ArrayList</span>&lt;&gt;();
        fullMessages.<span class="text-yellow-300">add</span>(<span class="text-purple-400">new</span> <span class="text-yellow-300">SystemMessage</span>(systemPrompt));
        fullMessages.<span class="text-yellow-300">addAll</span>(messages);
        <span class="text-purple-400">return</span> <span class="text-yellow-300">generate</span>(fullMessages);
    }

    <span class="text-gray-500">/**
     * 单字符串生成
     * 便捷方法，包装为 UserMessage
     */</span>
    <span class="text-gray-500">@Override</span>
    <span class="text-purple-400">public</span> <span class="text-blue-300">Response&lt;AiMessage&gt;</span> <span class="text-yellow-300">generate</span>(<span class="text-blue-300">String</span> userMessage) {
        <span class="text-blue-300">List&lt;ChatMessage&gt;</span> messages = <span class="text-blue-300">List</span>.<span class="text-yellow-300">of</span>(<span class="text-purple-400">new</span> <span class="text-yellow-300">UserMessage</span>(userMessage));
        <span class="text-purple-400">return</span> <span class="text-yellow-300">generate</span>(messages);
    }

    <span class="text-gray-500">/**
     * Token 计数
     * 用于估算 LLM 调用成本
     */</span>
    <span class="text-purple-400">public</span> <span class="text-blue-300">int</span> <span class="text-yellow-300">estimateTokenCount</span>(<span class="text-blue-300">String</span> text) {
        <span class="text-gray-500">// 简单实现：假设 1 token ≈ 4 个字符</span>
        <span class="text-purple-400">return</span> (text.<span class="text-yellow-300">length</span>() + <span class="text-orange-300">3</span>) / <span class="text-orange-300">4</span>;
    }

    <span class="text-gray-500">/**
     * 获取模型信息
     * 可用于调试和监控
     */</span>
    <span class="text-purple-400">public</span> <span class="text-blue-300">String</span> <span class="text-yellow-300">getModelInfo</span>() {
        <span class="text-purple-400">return this</span>.<span class="text-yellow-300">getClass</span>().<span class="text-yellow-300">getSimpleName</span>();
    }

    <span class="text-gray-500">/**
     * 资源清理
     * 关闭连接池、释放资源
     */</span>
    <span class="text-purple-400">public void</span> <span class="text-yellow-300">close</span>() {
        <span class="text-gray-500">// 默认实现：无需操作</span>
        <span class="text-gray-500">// 子类可重写以释放特定资源</span>
    }
}</code></pre>
                    </div>
                </section>

                <!-- 总结 -->
                <div class="bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl p-8 text-white">
                    <h3 class="text-2xl font-bold mb-4">本章小结</h3>
                    <p class="mb-4">深度解析了 LangChain4j 的内部架构、设计模式和扩展机制。通过理解这些底层原理，您可以：</p>
                    <ul class="list-disc list-inside space-y-2 mb-6">
                        <li><strong>自定义扩展</strong>：实现自己的 ChatModel、Memory、Tool 等组件</li>
                        <li><strong>性能优化</strong>：根据应用场景选择合适的调用模式和存储策略</li>
                        <li><strong>问题诊断</strong>：通过源码理解快速定位和解决问题</li>
                        <li><strong>架构设计</strong>：借鉴 LangChain4j 的设计模式应用到自己的项目</li>
                    </ul>
                    <div class="border-t border-indigo-400 pt-6">
                        <p class="text-sm opacity-80 mb-2">核心特性</p>
                        <div class="flex flex-wrap gap-2 mb-4">
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">模块化架构</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">插件系统</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">扩展点</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">线程安全</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">异步支持</span>
                        </div>
                        <p class="text-sm opacity-80 mb-2">技术栈</p>
                        <div class="flex flex-wrap gap-2 mb-4">
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">Java 17+</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">LangChain4j</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">SPI</span>
                            <span class="px-3 py-1 bg-white/20 rounded-full text-sm">CompletableFuture</span>
                        </div>
                        <a href="error-handling.html" class="inline-flex items-center gap-2 text-white hover:text-indigo-200 transition-colors">
                            下一章：错误处理 →
                        </a>
                    </div>
                </div>
            </div>
        </main>
    </div>
</body>
</html>
